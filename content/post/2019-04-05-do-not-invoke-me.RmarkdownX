---
title: Do not invoke me, apply yourself
author: c1au6i0
date: '2019-04-05'
slug: do-not-invoke-me
categories:
  - R
tags:
  - purrr
  - functions
  - non-standard evaluation
lastmod: '2019-04-05T23:01:25-04:00'
keywords: []
description: ''
comment: yes
toc: yes
autoCollapseToc: no
contentCopyright: no
reward: no
mathjax: no
---
You know how to apply a function to a list of elements (```apply```, ```purrr:map```) but can we do something similar to apply a **list of functions** to the same data?

<!--more-->

```{r message=FALSE}
library(tidyverse)
library(PRROC)
library(purrr)
library(rlang)
library(lobstr)
```

In this post, before xxx I will refresh



# MAP and iteration over multiple dataframes

```{r generate_dfs, eval=TRUE, include=FALSE}
create_values <- function(seed) {
  set.seed(seed)
  tibble(prob = runif(1000, min = 0, max = 1),
             lab = rbinom(1000, 1, 0.5))
}

dfs <- map(c(16, 15), create_values)
names(dfs) <- c("df1", "df2")
```

Let's suppose that we want to calculate the area under the roc curve for ```dfs$df1```, a dataframe with probabilities and corresponding class.

```{r str}
str(dfs)
```

In the previous post we have seen, that AUC of roc curves can be easily calculated with the package ```PRROC```

```{r}
roc_1 <- roc.curve(scores.class0 = dfs$df1$prob, weights.class0 = dfs$df1$lab, curve = TRUE)
roc_1
```

If we want to calculate the AUC also for the second dataframe will end it up with something like this:

```{r}
roc_1 <- roc.curve(scores.class0 = dfs$df1$prob, weights.class0 = dfs$df1$lab, curve = TRUE)

roc_2 <-  roc.curve(scores.class0 = dfs$df2$prob, weights.class0 = dfs$df2$lab, curve = TRUE)
```


xxxx there is still duplicated code: the arguments vary only by the dataframe name. We can create a function that given a dataframe with columns named ```prob``` and ```lab``` calculate the Area Under the ROC curve. 

```{r}
roc_df <- function(df, ... ) {
  roc.curve(scores.class0 = df$prob, 
                      weights.class0 = df$lab, ...)
}

roc_df(df = dfs$df1, curve = TRUE)
```

Now we can apply that function ot our list of dataframes with ```purrr::map```

```{r}
map(dfs, .f = roc_df, curve = TRUE)
```

Isn't that a cleaner code? OK, we had seen how to apply a function to a list of dataframes, now we will try to apply a list of functions to a dataframe.

# Invoke? Not anymore


```{r}
arg <- list(scores.class0 = dfs$df1$prob, weights.class0 = dfs$df1$lab)
map(list(roc.curve, pr.curve), exec, !!!arg)
```


```{r}
args1 <- list(scores.class0 = dfs$df1$prob, weights.class0 = dfs$df1$lab)

args2 <- list(scores.class0 = dfs$df2$prob, weights.class0 = dfs$df2$lab)

map2(rep(list(roc.curve, pr.curve),2), 
      rep(list(args1, args2), each = 2), 
      function(fn, args) exec(fn, !!!args))

ast(list(scores.class0 = dfs$df1$prob, weights.class0 = dfs$df1$lab))
```


```{r}
rocpr_df <- function(df, stat = c("roc", "pr"), ...) {
  if (missing(stat)) stat = "roc"
  fun_c <-  paste0(stat, ".curve")
  eval(expr((!!fun_c)(scores.class0 = df$prob, 
                      weights.class0 = df$lab,...)))
}


roc_df <- function(df, ...) {
  if (missing(stat)) stat = "roc"
  fun_c <-  paste0(stat, ".curve")
  eval(expr((!!fun_c)(scores.class0 = df$prob, 
                      weights.class0 = df$lab,...)))
}


arg1 = list(dfs$df1, "roc")
arg2 = list(dfs$df1, "pr")
arg3 = list(dfs$df2, "roc")
arg4 = list(dfs$df2, "pr")


prova <- list(arg1, arg2)

map2(list(rocpr_df, rocpr_df), prova, function(fn, args) exec(fn, !!!args))


prova <- expand.grid(dfs, list("roc", "pr"))

eval(parse_expr("5 + 5"))

eval(prova)

ast(expr("1 + 2"))
```



